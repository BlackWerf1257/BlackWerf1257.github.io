---
layout: post
title:  "객체지향프로그래밍 0425 공부"
tags: [Kmove, K-Move_C#]
---

## 공부

### 객체지향 언어의 특징

#### 객체 지향 언어의 장점

##### 개발 생산성 향상

- 잘 설계된 클래스는 다른 곳에서도 재활용 가능해서 개발 시간이 단축됨

##### 실세계의 사물과 비슷한 형태로 구현됨

- 현실의 사물과 비슷한 형태로 메소드와 속성을 클래스로 구현하고, 객체를 생성하여 이용이 가능함

##### 코드의 재사용성을 극대화

- 프로그램 내에서 자식 클래스가 상위 클래스의 코드를 재사용하여, 새로운 프로그램의 개발이 가능함

##### 유지보수의 용이성

- 객체지향 언어에서는 객체를 중심으로 프로그램이 작동하므로, 문제 발생 시 문제가 있는 객체만 수정하면 해결이 가능함

<br>

#### 객체지향 언어의 대표적 특징

##### 추상화

- 특정 사물을 **class**라는 키워드를 이용해 구현하는 것

##### 캡술화

- 데이터나 코드의 형태를 외부에서 알수없게 하여, 데이터의 구조와 역활, 기능을 하나의 캡슐의 형태로 만드는 것
- **접근제한자**를 이용해 데이터나 코드를 외부로 부터 보호할 수 있으며 이를 **정보 은닉**이라고 함
  - 접근 제한자의 종류로는 **private, public, protected, internal**이 존재함
- 데이터의 구조와 역활을 멤버 변수 및 프로퍼티를 이용해 구현하고, 기능은 메소드로 구현함

##### 상속

- 부모 클래스의 속성과 기능을 자식 클래스가 이어받는 것
- C#에서는 **자식클래스명:부모클래스명{}**의 형태로 상속받음
- 대부분의 객체지향 언어에서는 한 클래스에서 하나의 클래스만 상속이 가능함
  - 2개의 클래스를 상속 받을 경우, 어떤 클래스의 메소드를 불러와야하는지 애매모호한 문제가 있다
  - 이를 다이아몬드 상속 문제라고 하며, C++에서는 예외적으로 클래스의 중복 상속이 가능함

###### 장점

- 부모 클래스의 기능을 모두 가져오므로, 자식 클래스에서 새로 구현할 필요가 없음
- 부모 클래스의 기능을 수정하면, 자식 클래스에서도 기능이 변경되므로 기능 확장이 편리함

##### 다형성

- 어떤 객체의 속성이나 기능이 **여러 형태를 가질 수 있는 성질**
- 메소드 오버로딩과 오버라이딩이 이에 해당됨
- 메소드 오버로딩은 동일 클래스 내에서 메소드의 이름이 같지만, 매개변수 개수와 같이 기능이 다른 것을 의미함
- 메소드 오버라이딩은 상속관게에서 메소드 이름이 같은 것을 의미하며, 오버라이딩을 할 경우, <br>부모 클래스 내의 같은 이름의 메소드가 존재감이 상속됨

<br>

<br>

<br>

### 메소드 오버로딩과 오버라이딩

1. 특정한 기능을 수행할수 있도록 여러 명령문들을 묶어서 구성한 것을 (      )라고 한다.
   - **메소드**

2. 메소드는 다른 이름으로 (   )라고 부른다
   - **함수**

3. 아래 예 에서 접근제한자는 (   )이고 반환형은 (   )이고 메소드 이름은 (     )이고 매개변수는 (   )이다.
   - 접근제한자: **public**
   - 반환형: **int**
   - 메소드 이름: **AddTwoNumbers**
   - 매개변수: **a, b**

~~~c#
public int AddTwoNumbers(int a, int b) { return a + b; }
~~~

<br>

4. 3의 예제를 호출할때 3과 4를  이 함수에 전달하는 것을 코드로 작성하면 (      )이다

- **AddTwoNumbers(3,4)**

<br>

5.  (    )은 동일한 클래스 내에서 메소드 이름이 중복된 것을 말하는데 (    )은 같고 (   ) 또는 (   )이 다른 경우를 말한다.

- **오버로딩**
- **함수명**
- **매개변수**

<br>

6. 아래 예를 보고 답하시오

a. 메소드에는 (   ), (   ), (   ), (   ), (   )이 있다.

1. Add(int a, int b)
2. Add(int a, int b, int c)
3. Add(double A, double b)
4. Add(int a, int b)

b. 메소드 오버로딩 된 메소드는 (   ), (   ), (   )이 있다.

- Add(int a, int b, int c)
- Add(double A, double b)
- Add(int a, int b)

c. 메소드 오버로딩이 되지 않는 메소드에는 (   ), (   )이 있다.

- Main(String[] args)
- Add(int a, int b)

d. c에서 메소드 오버로딩이 되지 않는 이유는 무엇인가?

- C#에서는 메소드 오버로딩을 할때, 메소드 이름과 매개변수만으로 정의 되기 때문에, 반환형이 달라도 매개변수가 같으면 오버로딩이 불가능하다

e. calc.Add(3, 4)가 실행될때 호출되는 메소드는 (    )이고 이 메소드가 호출되는 이유는 무엇인가?

- 호출되는 메소드: **int Add(int a, int b)**
- 호출되는 이유: 매개변수인 3과 4는 모두 정수형이므로, 두 개 모두 int형을 가진 Add(int a, int b)가 호출된다

f. 만약 calc.Add(3.4, 4)가 실행될때 호출되는 메소드는 (    )이고 이 메소드가 호출되는 이유는 무엇인가?

- 호출되는 메소드:  **int Add(double a, double b)**
- 호출되는 이유: 첫번째 매개변수인 3.4는 뒤에 f가 붙어있지 않으므로, double형이다.<br>                         이때문에 매개변수로 double형을 가지는 Add함수가 호출된다

<br>

~~~c#
public class Calculator
{
	// 두 정수를 더하는 메소드
	public int Add(int a, int b)
	{
	return a + b;
	}
	// 세 정수를 더하는 메소드
	public int Add(int a, int b, int c)
	{
	    return a + b + c;
	}
	
	// 두 실수를 더하는 메소드
	public double Add(double a, double b)
	{
	    return a + b;
	}
      public double Add(int a, int b)	{
	    return (double) (a + b);
	}
	static void Main(String args[]) {
		Calculator calc = new Calculator();
		Console.WriteLine(calc.Add(3, 4));       
		Console.WriteLine(calc.Add(3, 4, 5));   
		Console.WriteLine(calc.Add(1.2, 3.4));   
    }
   }
~~~

<br>

7. 상속관계 클래스 간에서 부모 클래스의 메소드를 자식 클래스에서 재정의하는 것을 (   )라고 한다.

- **메소드 오버라이딩**

<br>

8. 8번 답을 위해 부모 클래스 메소드에  (  ) 키워드를 사용하고 자식 클래스에 메소드에는 (  ) 키워드를 사용한다.

- **virtual**
- **override**

<br>

9. 아래 예를 보고 답하시오

a. 부모 클래스는 (   )이고 부모 클래스의 메소드는 (   )이다.

- 부모 클래스: **Shape**
- 부모 클래스의 메소드: **draw()**

b. Shape클래스의 자식 클래스는 (   ), (   ), (   )이고 모두 (   )메소드가 있다

- 자식 클래스
  - Rect, Circle
- 공통된 메소드
  - draw

c. 문법적 오류는 수정하고 이 소스를 출력한 결과는?

d. 출력한 결과를 보고 for문에서 shape.draw();를 호출할때 실행되는 클래스의 메소드를 기록한다

~~~c#
shape1: Shape.draw() Shape->draw();
rect1: Rect.draw() Rect->draw();
rect2: Shape.draw() Rect->draw();
circle1: Circle.draw() Circle->draw();
circle2: Shape.draw() Circle->draw();
~~~



e. 객체명    호출되는 클래스의 메소드      실제 출력되는 메소드

shape1:   Shape.draw()                            Shape.draw();



f. d의 결과를 보고 메소드 오버라이딩을 설명하시오.

- 부모 클래스인 Shape에서는 draw() 함수를 호출하면 **Shape->draw**라는 문자를 출력하지만, 이 클래스를 상속받는 클래스인 Circle과 Rect 클래스에서

  호출하면 각각 **Circle->draw()**, **Rect->draw()**라는 문자를 출력한다.

- 위의 예시와 같이 상속받은 클래스에서 부모 클래스의 메소드를 새로 정의하는 것을 메소드 오버라이딩이라고 한다

g. 아래의 예에서 virtual과 override를 삭제하고 실행한 결과와 c의 결과를 비교하시오.

~~~c#
class Shape{
   virtual void draw(){
       Console.WriteLine(“Shape->draw());
 }	
}
class Circle: Shape{  //Circle클래스에 Shape클래스를 상속받음
    override void draw(){ //draw메소드가 오버라이딩
        Console.WriteLine("Circle->draw()");
}
}
class Rect: Shape{
     override void draw(){//draw메소드가 오버라이딩
          Console.WriteLine("Rect->draw()");
     }
}
class Overriding{
     static void Main(string args[]) {  
          Shape shape1= new Shape(); // 왼쪽의 클래스형 Shape와 오른쪽 new 다음의 클래스형이 동일함
          rect rect1= new Rect();//  왼쪽의 클래스형 Rect와 오른쪽 new 다음의 클래스형이 동일함
          shape rect2= new Rect(); // 왼쪽의 클래스형 Shape와 오른쪽 new 다음의 클래스형이 Rect로 다름
          Circle circle1= new Circle();//  왼쪽의 클래스형 Rect와 오른쪽 new 다음의 클래스형이 동일함
          shape circle2= new Circle();//왼쪽의 클래스형 Shape와 오른쪽 new 다음의 클래스형이 Rect로 다름
          ArrayList<Shape> arrShape= new ArrayList<>();
          arrShape.add(shape1);//arrShape변수에 shape1을 추가한다. 
          arrShape.add(rect1);//이어서 arrShape변수에 rect을 추가한다. 
          arrShape.add(rect2);
          arrShape.add(circle1);
          arrShape.add(circle2);
          foreach (Shape shape in arrShape) //arrshape에서 순차적으로 하나 빼와서 부모 클래스형으로 가르킨다
            shape.draw();// 가르키는 형의 draw()를 호출한다.
 }
~~~



